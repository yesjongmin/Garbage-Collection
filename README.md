# 가비지 컬렉션(Garbage-Collection)
### 가비지 컬렉션이란 ?
* 프로그램을 개발 하다 보면 유효하지 않은 메모리인 가비지(Garbage)가 발생하게 되는데 이러한 가비지는 불필요하게 메모리를 점유하게 됩니다. 가비지 컬렉션은 메모리 관리 기법 중 하나로 프로그램이 동적으로 할당했던 메모리 영역 중에서 필요없게 된 영역을 해제하는 기능입니다.

### 가비지 컬렉션의 필요성
* 현대적인 언어가 아닌 과거 언어인 경우, 메모리 관리를 직접 해줘야 하는 언어들은 크게 두 가지 문제점을 가지고 있습니다.
1. 필요 없는 메모리를 비우지 않았을 때 : 메모리 사용을 마쳤을 때 비우지 않을 경우 메모리 누수가 발생할 수 있고 장기적인 관점에서 심각한 문제가 발생할 수 있다.
2. 사용중인 메모리 비우기 : 존재하지 않는 메모리에 접근하려고 하면 프로그램이 중단되거나 메모리 데이터 값이 손상될 수 있다.

이러한 문제를 해결하기 위해 java, python 등 현대적인 언어는 자동 메모리 관리를 갖추게 되었습니다.

# 가비지 컬렉션 메소드
* 가비지 컬렉션 메소드에는 대표적으로 3가지가 있습니다.

1. Mark and Sweep
2. Reference count
3. Generational Garbage Collection

### 1. Mark and Sweep(표시하고 쓸기)
* Mark and Sweep은 각 메모리 영역에 1비트씩 남겨둔 후, 변수가 가리키는 영역과 그 영역이 가리키는 또 다른 영역을 모두 '사용 중'으로 표시합니다. 
* 이 때 '사용 중'으로 표시되지 않은 나머지 영역을 없애는 기법입니다.

### 2. Reference count(참조 횟수 계산)
* 파이썬의 주된 가비지 콜렉션 메커니즘은 Reference count입니다. 파이썬에서 어떤 객체를 생성하면, C  수준 객체는 이 파이썬 객체의 타입과 reference count를 가지고 있게 됩니다.
  * reference count는 객체가 참조될 때마다 +1, 해제될 때 -1로 계산됩니다. 이렇게 각 객체의 참조 횟수를 count하여 0이 되면 해당 객체를 해제하는 방식을 말합니다.
  * 이때 객체의 카운트가 0이라는 뜻은 더이상 이 객체에 접근하고 있는 코드가 없다는 의미이므로 메모리에서 삭제, 즉 할당 해제(deallocation)를 할 수 있게 되고, 바로 이 때 객체가 지워지게 됩니다. 따라서 안전하게 해당 메모리를 "즉시" 확보 가능합니다.

#### Reference count 확인
* sys 라이브러리를 사용해서 특정 객체의 Reference count를 확인할 수 있으며, 참조 횟수를 증가시키는 방법은 다음과 같습니다.
    * 객체를 변수에 할당
    * 객체를 리스트, 튜플과 같은 자료구조에 하거나 인스턴스 프로퍼티로 추가
    * 함수에 파라미터로 전달
 
위의 내용을 테스트 해보면, 

        >>> import sys
        >>> a = 'hello'
        >>> sys.getrefcount(a)
        2

Reference count가 2인걸 알 수 있습니다. 1은 처음 객체가 a 에 할당되는 순간에 증가하고, 2는 sys.getrefcount()함수에 전달되는 순간에 증가하게 됩니다.

재시작하고 리스트와 딕셔너리에 객체를 추가해보면

        >>> import sys
        >>> a = 'hello'
        >>> sys.getrefcount(a)
        2
        >>> b = [a]
        >>> sys.getrefcount(a)
        3
        >>> c = {'first': a}
        >>> sys.getrefcount(a)
        4

 list나 dictionary에 추가될 때 a의 참조 횟수가 증가하는 것을 알 수 있습니다.
 
하지만 객체가 자기 자신을 가르키는 '순환참조'를 하게 될 경우 Reference count 방식으로는 메모리에서 해제 될 수 없습니다.
      
      >>> a = []
      >>> a.append(a)
      >>> del a
      
위의 코드와 같이 a의 참조 횟수는 1이지만 이 객체는 더 이상 접근할 수 없으며 Reference count 방식으로는 메모리에서 해제될 수 없는 것을 볼 수 있습니다.      

또 다른 예로는 서로를 참조하는 객체입니다.

    >>> a = Func_pr() # 0x01
    >>> b = Func_pr() # 0x02
    >>> a.x = b # 0x01의 x는 0x02를 가리킨다.
    >>> b.x = a # 0x02의 x는 0x01를 가리킨다.
    # 0x01의 레퍼런스 카운트는 a와 b.x로 2다.
    # 0x02의 레퍼런스 카운트는 b와 a.x로 2다.
    >>> del a # 0x01은 1로 감소한다. 0x02는 b와 0x01.x로 2다.
    >>> del b # 0x02는 1로 감소한다.

마지막 상태에서 0x01.x와 0x02.x가 서로를 참조하고 있기 때문에 레퍼런스 카운트는 둘 다 1이지만 0에 도달할 수 없는 garbage(쓰레기)가 되는 것을 알 수 있습니다.

이러한 유형의 문제를 reference cycle(참조 주기)이라고 하며 reference counting으로 해결할 수 없습니다.

### 3. Generational Garbage Collection(세대 단위 쓰레기 수집)
* Generational Garbage Collection에는 두가지 핵심이 있습니다.

1. 세대(generation)
* 가비지 컬렉터는 메모리의 모든 객체를 추적합니다.
* 새로운 객체는 1세대 가비지 수집기에서 life(수명)를 시작합니다.
* Python이 세대에서 가비지 수집 프로세스를 실행하고 객체가 살아남으면, 두 번째 이전 세대로 올라갑니다.
* Python 가비지 수집기는 총 3세대이며, 객체는 현재 세대의 가비지 수집 프로세스에서 살아남을 대마다 이전 세대로 이동합니다.

2. 임계(threshold)값
* 각 세대마다 가비지 컬렉터 모듈에는 임계값 개수의 개체가 있습니다.
* 객체 수가 해당 임계값을 초과하면 가비지 콜렉션이 콜렉션 프로세스를 trigger(추적) 합니다.
* 해상 프로세스에서 살아남은 객체는 이전 세대로 옮겨집니다.





# 가비지 컬렉션의 단점
* 가비지 컬렉션을 수행하려면 응용 프로그램을 완전히 중지해야 한다. 그러므로 객체가 많을수록 모든 가비지를 수집하는 데 시간이 오래 걸린다는 것도 분명합니다.
* 가비지 컬렉션 주기가 짧다면 응용 프로그램이 중지되는 상항이 증가하고 반대로 주기가 길어진다면 메모리 공간에 가비지가 많이 쌓일 것입니다.

------
###### 참고사이트 : https://medium.com/dmsfordsm/garbage-collection-in-python-777916fd3189, 
